<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Cosmic Graphs: the Language of Large-Scale Structure | T. Lucas Makinen</title> <meta name="author" content="T. Lucas Makinen"> <meta name="description" content="how much information is locked inside halo catalogues?"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://tlmakinen.github.io/blog/2022/cosmicgraphs/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Cosmic Graphs: the Language of Large-Scale Structure",
      "description": "how much information is locked inside halo catalogues?",
      "published": "September 12, 2022",
      "authors": [
        {
          "author": "T. Lucas Makinen",
          "authorURL": "https://en.wikipedia.org/wiki/Albert_Einstein",
          "affiliations": [
            {
              "name": "Imperial College London",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">T. Lucas </span>Makinen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"></a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/music/">music</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"></a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/cv/">cv</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Cosmic Graphs: the Language of Large-Scale Structure</h1> <p>how much information is locked inside halo catalogues?</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#cosmology-as-an-optimization-problem">Cosmology as an optimization problem</a></div> <div><a href="#graphs-a-language-for-large-scale-structure">Graphs: a Language for Large-Scale Structure</a></div> <div><a href="#graph-neural-networks">Graph Neural Networks</a></div> <div><a href="#part-i-varying-graph-connections-and-gnn-complexity">Part I: varying graph connections and GNN complexity</a></div> <div><a href="#part-ii-incorporating-halo-mass">Part II: Incorporating Halo Mass</a></div> <div><a href="#part-iii-a-more-realistic-case-adding-survey-noise">Part III: A more realistic case: adding survey noise</a></div> <div><a href="#closing-thoughts">Closing Thoughts</a></div> </nav> </d-contents> <figure class="align-center"> <p align="center"> <img src="https://media4.giphy.com/media/b8ICuMdjg37vQNjwTA/giphy.gif?cid=790b7611da6738a8551bc2d92f2eb821b6d853092aa22ca9&amp;rid=giphy.gif" alt="dark matter graph" style="width:70%" zoomable="true"> </p> <figcaption align="center"> </figcaption> </figure> <p><br></p> <div style="display: block; margin-left: auto; margin-right: auto; width:100%; text-align:center;"> <a href="https://arxiv.org/abs/2207.05202" class="btn btn--primary" rel="external nofollow noopener" target="_blank">read the paper</a> <a href="https://github.com/tlmakinen/cosmicGraphs" class="btn btn--primary" rel="external nofollow noopener" target="_blank">get the code</a> <a href="https://bit.ly/cosmicGraphsColab" class="btn btn--primary" rel="external nofollow noopener" target="_blank"> <i class="fab fa-google fa-inverse"></i> run in browser </a> </div> <p><br></p> <p><em>With Tom Charnock, Pablo Lemos, Natalia Porqueres, Alan Heavens, &amp; Ben Wandelt</em></p> <p>The cosmic web, or Large-Scale Structure (LSS) is the massive spiderweb-like arrangement of galaxy clusters and the dark matter holding them together under gravity. The lumpy, spindly universe we see today evolved from a much smoother, infant universe. How this structure formed and the information embedded within is considered one of the “Holy Grails” of modern cosmology, and might hold the key to resolving existing “tensions” in cosmological theory.</p> <p>But how do we go about linking this data to theory ? In this project, my team and I will propose to look at LSS assembled as a <em>graph</em>, and use neural networks to optimally extract information about cosmological parameters (theory) from this representation.</p> <h1 id="cosmology-as-an-optimization-problem">Cosmology as an optimization problem</h1> <p>Large-Scale Structure is <em>large</em>. The image below shows a piece of a simulation of the cosmic web (\(125\ {\rm Mpc} = 125 \times 10^6\) light years). This massive expanse translates into a lot of data for cosmologists to work with. For context, the European Satellite <a href="https://www.esa.int/Science_Exploration/Space_Science/Euclid_overview#:~:text=Mission%20objectives%3A,a%20third%20of%20the%20sky." rel="external nofollow noopener" target="_blank">Euclid</a> will observe <em>billions</em> of galaxies and their properties in an effort to trace the LSS and the dark matter halos forming the cosmic web. Ideally, we’d use the full <a href="https://arxiv.org/abs/2107.07405" rel="external nofollow noopener" target="_blank">field-level image of this structure</a>, but this can be challenging when we have billions of pixels.</p> <figure style="width: 60%" class="center"> <img src="https://raw.githubusercontent.com/tlmakinen/cosmicGraphs/master/tutorial/cosmicvoid.jpeg" alt="drawing" align="center"> <div class="caption"> Simulation of cosmic structure. Credit: <a href="https://wwwmpa.mpa-garching.mpg.de/galform/virgo/millennium/" rel="external nofollow noopener" target="_blank"> Millenium Simulation Project. </a> </div> </figure> <p>Cosmology can be thought of as a multigenerational <em>optimization problem</em>, with the objective being:</p> <blockquote> <p>What statistic (what number(s)) best links LSS data to theory ?</p> </blockquote> <p>Since the 1960’s, cosmologists have used \(n\)-point functions to describe structure formation. The image data collected by state-of-the-art surveys are often immediately compressed into (still very large) galaxy and cluster catalogues, whose pairwise (2-point), triplet (3-point), … distances can be compared to quantify how clustered the universe is on different scales.</p> <figure class="center"> <a href="/assets/img/cosmographs/twopoint-pk.png" title="a graph diagram" alt="graph diagram"> <p align="center"> <img src="/assets/img/cosmographs/twopoint-pk.png" alt="" style="width:35%" align="center"> </p> </a> <div class="caption"> <b> Figure 1 </b> - <a href="https://universe-review.ca/" rel="external nofollow noopener" target="_blank"> The two-point function </a> in real space can be related to the power spectrum in Fourier space. It only fully describes Gaussian field statistics. </div> </figure> <p>2-point functions are easy to compute even for large data, but <em>don’t capture all the information in highly non-gaussian fields</em>, like the LSS. 3-point functions reclaim a lot of this information, but are much more expensive to compute.</p> <h1 id="graphs-a-language-for-large-scale-structure">Graphs: a Language for Large-Scale Structure</h1> <figure class="align-center"> <p align="center"> <img src="https://media4.giphy.com/media/b8ICuMdjg37vQNjwTA/giphy.gif?cid=790b7611da6738a8551bc2d92f2eb821b6d853092aa22ca9&amp;rid=giphy.gif" alt="dark matter graph" style="width:70%"> </p> <div class="caption"> <b> Figure 2 </b>- Large-Scale Structure as a Graph. Nodes (halos) trace clusters, while edges (halo separations) trace filaments and outline voids. Both sets of features can be annotated with extra information like mass or redshift. </div> </figure> <p>Graphs provide a natural language with which to describe the cosmic web. Dark matter halos are attributed to nodes (vertices), while filaments are traced by smaller halos and edges. In this representation, clustering under gravitational interactions can be translated into higher edge cardinality (number of edges). Higher order n-point functions can be computed efficiently for clusters, while avoiding the cost of computing extraneous connections across voids. Void catalogues (where edges would correspond to the walls separating the voids) can likewise be assembled into the dual of a halo graph. Graph construction also allows extra information, such as the halo masses, to be added in the form of node and edge labels, unlike correlation functions.</p> <figure class="align-center"> <p align="center"> <img src="https://raw.githubusercontent.com/tlmakinen/cosmicGraphs/master/tutorial/peebles.jpeg" alt="jim peebles" style="width:20%"> </p> <div class="caption"> <a href="https://www.nobelprize.org/prizes/physics/2019/peebles/facts/" rel="external nofollow noopener" target="_blank"> Jim Peebles </a>, 2019 Nobel Prize Winner. </div> </figure> <p>This language is a lot more general – Ben even thought Jim Peebles might have described the cosmic web with graphs if he’d had the resources to do so in 1967.</p> <h2 id="what-is-a-graph-">What is a graph ?</h2> <figure class="center"> <a href="/assets/img/cosmographs/graph_diagram.png" title="a graph diagram" alt="graph diagram"> <p align="center"> <img src="/assets/img/cosmographs/graph_diagram.png" alt="" style="width:35%" align="center"> </p> </a> <div class="caption"> Graph Diagram. </div> </figure> <p>Before we delve into the machinery, let’s define some vocabulary for looking at data on graphs. We can define a graph as a tuple,</p> <p>\(\begin{equation} G = (\textbf{u}, V, E),\label{eq:graphdef} \end{equation}\) where \(\textbf{u}\) is a global attribute of the graph, i.e. a label or global parameter value and \(E\) and \(V\) are the set of edges and nodes, respectively. The edge set</p> \[E = \{({\bf e}_k, r_k, s_k) \}_{r_k = i, k=1:N^e},\] <p>indexed by \(k=1:N^e\), is comprised of vectors \({\bf e}_k\) of cardinality \(N^e\), which may be directed, connected via receiving and sending indices between nodes, \(r_k\) and \(s_k\). Edges can be equivalently parameterized by an adjacency matrix \(A_{ij}\) in which \(i\) and \(j\) index sender and receiver nodes, respectively. Each node, indexed by \(i=1:N^v\), has a set of edges, \(E_i\), connected to it via a subset of senders and receivers. The full set of nodes is defined as</p> \[V= \{\textbf{v}_i \}_{i=1:N^v},\] <p>where each node \(\textbf{v}_i\) is a vector of features. In a physical system of particles, one might represent \(V\) as a set of individual particles’ attributes, like mass, position, and velocity, with edges expressing interactions, such as forces, between particles.</p> <blockquote> <p>Graphs are a really general way to think about arbitrary data representation. For instance, images can be thought of as nodes (pixels) arranged on a 2D lattice (regularly-spaced edges).</p> </blockquote> <h2 id="dark-matter-halo-graphs-from-catalogues">Dark Matter Halo Graphs from Catalogues</h2> <p>To create a graph from a catalogue of dark matter halos (or galaxy clusters), we need to define two physical parameters:</p> <ol> <li>a mass cut, \(M_{\rm cut}\)</li> <li>a connection radius, \(r_{\rm connect}\)</li> </ol> <p>We trunctate a catalogue to halos with a minumum mass \(M_{\rm cut}\). We’ll then connect all remaining halos to all other halos within a radius of \(r_{\rm connect}\). In Figure 5, the dark points are halos with \(M_{\rm cut}=1.5\times10^{15} M_{\rm sun}\), while light points are halos with masses \(M_i &gt; M_{\rm cut}=1.1\times10^{15} M_{\rm sun}\).</p> <figure class="align-center"> <p align="center"> <img src="https://media4.giphy.com/media/b8ICuMdjg37vQNjwTA/giphy.gif?cid=790b7611da6738a8551bc2d92f2eb821b6d853092aa22ca9&amp;rid=giphy.gif" alt="drawing" style="width:70%"> </p> <div class="caption"> <b> Figure 3 </b> - Graphs are assembled by making a mass cut. The darker nodes and edges are heavier halos above $$ M_{\rm cut} = 1.5 \times 10^{15} M_{\rm sun} $$, while the lighter graph is smaller-scale structure at $$M &gt; 1.1 \times10^{15} M_{\rm sun}$$. </div> </figure> <p>These two physical parameters change the <em>cardinality</em> of the graph, or the length of the set of edges and nodes, which is now <em>an informative feature about cosmology</em>, as opposed to fixed-length data. The $M_{\rm cut}$ we selected gives us about 100 halos per <em>Quijote</em> simulation – this is a very small dataset, but still contains a wealth of information !</p> <h2 id="assembling-graphs">Assembling graphs</h2> <p>One of the goals of this study is to show how graphs can be made more ornate and aid in information extraction about cosmology from detailed dark matter simulations.</p> <figure class="center"> <p align="center"> <img src="/assets/img/cosmographs/inv-vs-noninv.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 4 </b> - Non-invariant graphs are restricted to grid labels on their nodes, while invariant graph properties remain unchanged under rotations and translations. </div> </figure> <p>We choose to assemble graphs in two ways: invariant and non-invariant. There has been a lot of research in the GNN community about “inductive biases” – this is just fancy lingo for smart data representation.</p> <blockquote> <p>The cosmological parameters we want to extract are global properties of the graph, \({\bf u}\), and should be the same if a universe is rotated or translated to another grid, provided the relative structure stays the same.</p> </blockquote> <p>Encoding these physical symmetries should make pulling out physical information easier, right? We test this hypothesis by using these two representations.</p> <p><strong>Invariant graphs</strong> have all <em>relative</em> positional information (distance and angles) stored in the edges. These graphs are <em>symmetric</em> or <em>invariant</em> under translations and rotations.</p> \[\begin{align} \textbf{e}_{ij} &amp;= [d_{ij}, \alpha_{ij}, \beta_{ij}]\ &amp;\texttt{# dist, angles between i and j} \\ \textbf{v}_i &amp;= [M_i], &amp;\texttt{# mass} \end{align}\] <p><strong>Non-invariant</strong> graphs are only labelled with relative distance information in the edges, with other positional information stored in the nodes as \((x_i,y_i,z_i)\) coordinates for each halo \(i\).</p> \[\begin{align} \textbf{e}_{ij} &amp;= d_{ij}\ \texttt{# dist between halos i and j} \\ \textbf{v}_i &amp;= [M_i, \textbf{p}_i],\ \texttt{# mass, (x,y,z) position} \end{align}\] <h1 id="extracting-information-from-graphs">Extracting Information from graphs</h1> <p>But how do we extract information from a set of edges and nodes whose size changes ? Enter graph Information Maximising Neural Networks (gIMNNs) ! Remember how cosmology can be thought of as an optimization problem to find informative statistics ? IMNNs do precisely that, from simulations !</p> <figure> <p align="center"> <img src="/assets/img/cosmographs/gIMNN-diagram-white-background.png" alt="drawing" style="width:100%"> </p> <div class="caption"> <b> Figure 5 </b> - IMNN scheme. Cosmic graphs are assembled from Dark Matter simulations, subjected to "survey" noise, and then extracted using graph neural networks to produce global summaries. The derivatives and covariance of these summaries are computed to calculate the Fisher information, which we train the networks to maximise. </div> </figure> <p>IMNNs optimizing the Cramer-Rao bound, which describes the average variance (uncertainty) of estimates of parameters \(\vartheta\):</p> \[\langle (\vartheta_\alpha - \langle \vartheta_\alpha \rangle )(\vartheta_\beta - \langle \vartheta_\beta \rangle) \rangle \geq \textbf{F}^{-1}_{\alpha \beta}\] <p>By <em>maximising</em> the Fisher information of some distribution, \(\textbf{F}\), we <em>minimize</em> the uncertainty in the parameters, better constraining the theory.</p> <p>IMNNs do this <em>automatically</em> by learning \(f: \textbf{d} \rightarrow \textbf{x}\), a mapping \(f\) from some big data \(\textbf{d}\) to a small set of summaries \(\textbf{x}\). We use neural networks to learn \(f\), since these can be trained via backpropagation on data !</p> <p>To do this, and without loss of generality (proof coming soon!) we compute a Gaussian likelihood form to compute our Fisher information:</p> \[\begin{equation} -2 \ln \mathcal{L}(\textbf{x} | \textbf{d}) = (\textbf{x} - \boldsymbol{\mu}_f(\vartheta))^T \textbf{C}_f^{-1}(\textbf{x} - \boldsymbol{\mu}_f(\vartheta)) \end{equation}\] <p>where $\boldsymbol{\mu}_f$ and $\textbf{C}$ are the mean and covariance of the network output, $\textbf{d}$ is the graph data input, and $\textbf{x}$ are network summaries. The Fisher is then</p> \[\textbf{F}_{\alpha \beta} = {\rm tr} [\boldsymbol{\mu}_{f,\alpha}^T C^{-1}_f \boldsymbol{\mu}_{f, \beta}]\] <p>Since we can’t differentiate through our halo construction, we’ll use <em>numerical gradients</em>, computed using compressed data simulated at $\vartheta^\pm = \vartheta \pm \Delta \vartheta$, our <em>derivative</em> datasets:</p> \[\left( \frac{\partial \hat\mu_i}{\partial \vartheta_\alpha} \right)^{s\ \rm fid} \approx \frac{1}{n_s}\sum^{n_s}_{i=1} \frac{\textbf{x}^{s\ \rm fid +}_i - \textbf{x}^{s\ \rm fid -}_i}{\Delta \vartheta^+_\alpha - \Delta \vartheta^-_\alpha}.\] <p>To prevent extra information being extracted from accidental correlation in limited sized data sets, reported statistics need to be computed on a <em>validation set</em> of simulations, which is unlikely to share the same accidental correlations as the fixed training set.</p> <blockquote> <p>What are the IMNN summaries, $\textbf{x}$ ? The output of the IMNN, unlike <em>regression</em> neural networks, is not a label. IMNN training is explicitly <em>unsupervised</em>, so the outputs of the network are somewhat arbitrary numbers (the value of the score of the underlying implicit likelihood). However, these numbers exist in a <a href="#simulation-based-inference-how-to-use-gimnns-in-practice">small subspace</a> that can be exploited for comparing compressed simulations to one another for simulation-based inference.</p> </blockquote> <p>If you’re curious, the details behind the IMNN algorithm <a href="https://arxiv.org/abs/1802.03537" rel="external nofollow noopener" target="_blank">can be found here on arxiv</a>.</p> <h2 id="graph-neural-networks">Graph Neural Networks</h2> <p>How do graph neural networks (GNNs) work under the hood ? GNNs have been the buzz for a while in the machine learning community. We use a generic GNN block (neural updates for edges, nodes, and globals), described in <a href="https://arxiv.org/abs/1806.01261" rel="external nofollow noopener" target="_blank">this paper</a>, but we’ll go over the basic algorithm here.</p> <p>A graph neural network (GNN) block typically consists of three update functions, \(\boldsymbol{\phi}=(\phi_u, \phi_v, \phi_e)\), and three aggregation functions, \(\boldsymbol{\rho} =(\rho^u, \rho^v, \rho^e)\), applied sequentially to a graph tuple \(G = (\textbf{u}, V, E)\). A single graph block $\ell$ is comprised of several update steps to its elements:</p> <ol> <li> <p><em>Edge update</em>: Each edge is parameterized by a function \(\phi^{\ell+1}_e\) which takes as inputs its connected nodes, previous value, and graph global properties and yields another edge: \(\textbf{e}_{ij}^{\ell + 1} = \phi^{\ell + 1}_e(\textbf{v}_i^\ell, \textbf{v}{j}^\ell, \textbf{e}_{ij}^\ell \textbf{u}^\ell),\) where \(\textbf{v}_{i}^\ell\) and \(\textbf{v}_{j}^\ell\) are sender and receiver nodes indexed by \((s_k, r_k)\).</p> </li> <li> <p><em>Node update</em>: Each node is then parameterized by a function \(\phi^{\ell + 1}_v\) and outputs a new node: \(\textbf{v}i^{\ell + 1} = \phi^{\ell+1}_v \left(\rho^{e \rightarrow v}(E_i^{\ell + 1}), \textbf{v}i^\ell, \textbf{u}^\ell \right),\) Here a permutation-invariant aggregation operation \(\rho^{e \rightarrow v}(E_i^{\ell + 1})\) pools the neighbourhood of edges \(E^{\ell + 1}_i\) connected to node $i$ into a fixed-sized vector to feed into the update function.</p> </li> <li> <p><em>Global update</em>: The global features of the graph are then updated with a function \(\phi^{\ell + 1}_u\): \(\textbf{u}^{\ell + 1} = \phi^u\left(\rho^{e\rightarrow v}(E^{\ell + 1}), \rho^{v \rightarrow u}(V^{\ell + 1}), \textbf{u}^\ell \right),\) where the graph’s edge (\(E^{\ell+1}\)) and node (\(V^{\ell+1}\)) sets are pooled into fixed-sized vectors for the global update.</p> </li> </ol> <p>The \(\boldsymbol{\phi}\) functions can be arbitrarily parameterized by neural networks, meaning we can nonlinearly pull out information from edges and node features. Furthermore, by allowing edges to propagate information to the nodes they connect, we can extract information from relevant neighborhoods of structure. The aggregation functions \(\boldsymbol{\rho}\) allow us to pool information over differently-sized graph features – this is super handy when your data size changes with cosmology !</p> <p>Stacking \(\ell = 1:N^{\rm int}\) GNN blocks allows node information to be propagated to and from neighbours \(N^{\rm int}\) degrees away, where \(\textrm{int}\) refers to <em>interactions</em>. In this work all GNN blocks operate over the entire graph.</p> <p>Graph neural networks fit nicely into the IMNN formalism. We can stack \(N^{\rm interaction}\) GNN blocks to extract information from clusters and edges in the graph, and finally aggregate that information into graph “globals”, in this case the set of gIMNN summaries are the global properties of the graph, \(\textbf{u} = \textbf{x}\). We can then use these summaries to optimize our Fisher calculation using backpropagation !</p> <h2 id="constraining-omega_m--sigma_8-in-the-imnn-formalism">Constraining \(\Omega_m\) &amp; \(\sigma_8\) in the IMNN formalism</h2> <p>Now we have all the tools to start extracting cosmological information from LSS assembled as a graph. We’re going to use the <em>Quijote</em> simulations to see how sensitive the cosmic graph is to the cosmological parameters \(\Omega_m\) (the matter fraction parameter) and \(\sigma_8\) (the parameter that controls fluctuations or “peakiness” in the density field).</p> <p>The <em>Quijote</em> simulation suite is designed for Fisher analyses. It is comprised of massive dark matter structure simulations on \((1 \rm Gpc)^3\) boxes (1 Gpc = 3261564220 light years !). These density fields are then used to assemble <em>halo catalogues</em> by using the Friend-of-Friends clustering algorithm.</p> <p>We’re going to use:</p> <ul> <li> <p>500 catalogue simulations at \(\boldsymbol{\vartheta}_{\rm fid} = (\Omega_m, \sigma_8) = (0.3175, 0.834)\) to estimate the covariance of the network outputs</p> </li> <li> <p>250 \(\times 4\) catalogue simulations at \(\boldsymbol{\vartheta}^{\pm} = \boldsymbol{\vartheta}_{\rm fid} \pm (0.01, 0.015) = \begin{bmatrix} \Omega^-_{m} &amp; \sigma^{\rm fid}_8\\ \Omega^{\rm fid}_m &amp; \sigma_8^- \\ \Omega^+_m &amp; \sigma^{\rm fid}_8 \\ \Omega^{\rm fid}_m &amp; \sigma_8^+ \end{bmatrix}\) to estimate the derivatives of the output of the network.</p> </li> </ul> <p>The <em>Quijote</em> suite contains enough universe simulations to make an equally-sized training and validation set of graphs to compute the Fisher statistics. The validation set is important such that the GNNs learn patterns such that they can generalise to unseen data.</p> <p>We built the IMNN and simulation scheme in the <code class="language-plaintext highlighter-rouge">Jax</code> framework. For detailed code implementaion, see the <a href="https://bit.ly/cosmicGraphsColab" rel="external nofollow noopener" target="_blank">Colab tutorial</a>.</p> <h1 id="part-i-varying-graph-connections-and-gnn-complexity">Part I: varying graph connections and GNN complexity</h1> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/cosmographs/info-extraction-cartoon-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/cosmographs/info-extraction-cartoon-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/cosmographs/info-extraction-cartoon-1400.webp"></source> <img src="/assets/img/cosmographs/info-extraction-cartoon.png" class="img-fluid rounded z-depth-0" width="auto" height="auto" title="example image" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b> Figure 6 </b> - Information extraction improves as graphs are made more ornate. </div> <p>We’re going to investigate increasingly decorated and physical representations of the cosmic graph. We’ll start with connecting <em>undecorated</em> halos with different \(r_{\rm connect}\) values. For this experiment <em>all neural network weights and architectures will be exactly the same from initialization</em> – this is to control for any variability that random intitalizations might introduce. As a baseline, we’ll compare the information contained in the two-point correlation function (2PCF) – the graphs should hold a lot more information about the parameters than this old technique !</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="https://raw.githubusercontent.com/tlmakinen/tlmakinen.github.io/master/assets/cosmographs/connect-compare3-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="https://raw.githubusercontent.com/tlmakinen/tlmakinen.github.io/master/assets/cosmographs/connect-compare3-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="https://raw.githubusercontent.com/tlmakinen/tlmakinen.github.io/master/assets/cosmographs/connect-compare3-1400.webp"></source> <img src="https://raw.githubusercontent.com/tlmakinen/tlmakinen.github.io/master/assets/cosmographs/connect-compare3.png" class="img-fluid rounded z-depth-0" width="auto" height="auto" title="example image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> <b> Figure 7 </b> - Adding symmetries to the graph (top row) and increasing network message-passing (left-to-right) speeds up information extraction. </div> <p>As expected, incorporating symmetries (Figure 8, top row) in the invariant representation speeds up information extraction, <em>since the network doesn’t need to figure out that relative clustering is more important than grid positions</em>. Folks in the GNN community call this a demonstration of <em>inductive bias</em> in neural network training. Additionally, increasing “connectivity” – in this case, by increasing \(r_{\rm connect}\) values (darker green) and/or increasing \(N^{\rm int}\) GNN blocks speeds up the network’s ability to pick out relevant features for maximising the Fisher information for the two parameters \((\Omega_m, \sigma_8)\).</p> <p>What is interesting is that even in most of the non-invariant cases we are able to pick out a similar level of information, albeit with longer training times. This is evidence that the cosmological information in our small dataset is easily saturated for the \(r_{\rm connect}\) scales studied here. Developing hierarchical schemes for probing smaller scales might be necessary with much bigger catalogues.</p> <h1 id="part-ii-incorporating-halo-mass">Part II: Incorporating Halo Mass</h1> <p>What happens when we decorate graphs with masses and train a gIMNN ? We get out twice as much information as for undecorated graphs !</p> <blockquote> <p>A quick aside: how much information is in a (fixed) statistic ? The plot above is what we call a “Fisher forecast” for cosmological parameters. It shows a <em>Gaussian Approximation</em> to the posterior for a given statistic (or likelihood), which can be plotted as an ellipse. 2PCF is the average clustering information collected by comparing pairs of halos across all the catalogues. We compute the 2PCF Fisher in the same way we compute the gIMNN finite-difference Fisher (except this time with the fixed 2PCF across simulations – no gradient descent here !) </p> </blockquote> <figure class="align-center"> <p align="center"> <img src="/assets/img/cosmographs/F-withmass-intfsigma.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 8 </b> - Fisher diagram comparing gIMNN extraction to halo mass and 2-pt correlation functions. </div> </figure> <p>There is a lot going on in this Fisher plot – let’s start with the dotted ellipse. This is the information extracted about the cosmological parameters from just the 2-point correlation function (2PCF), which probes clustering – think of it as our baseline. The grey lines that slice through the 2PCF ellipse are lines of <em>fixed mass</em> computed from a halo mass function, which tells us how the halo mass in the universe changes with changing \((\Omega_m, \sigma_8)\).</p> <p>Without going into the details, the main takeaway here is that the gIMNNs are able to <em>automatically combine mass and clustering information</em> along the correct axes to better constrain the parameters ! And we’ve done so in an <em>entirely unsupervised manner</em> ! In the paper we show that a lot of this information comes from the changing <em>cardinality</em> or number of halos in the graph.</p> <p>If you take an even closer look, you’ll see that the Fisher ellipse produced by the annotated graph and gIMNN <em>rotates</em> slightly towards the halo mass function (HMF) lines, away from the halo number density lines, when mass labels are added to the graph nodes.</p> <figure class="align-center"> <p align="center"> <img src="/assets/img/cosmographs/fsigma-dndms-comp.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 9 </b> - Fisher diagram comparing gIMNN extraction to halo mass and 2-pt correlation functions. </div> </figure> <h2 id="halo-mass-function-information">Halo Mass Function Information</h2> <p>To explain this behaviour, we need to dive into the HMF formalism. The fraction of mass found in halos per unit interval \(\ln \sigma^{-1}\) can be parameterized as a function, \(f(\sigma)\), called the halo mass function, which obeys</p> \[\begin{equation} \int_{-\infty}^\infty f(\sigma) d \ln \sigma^{-1} = 1, \end{equation}\] <p>and can be related to the <em>number density</em> of halos in a given interval, \(dn/dM\), via</p> \[\begin{equation} \frac{dn}{dM} = \frac{\rho_o}{M}\frac{d\ln \sigma^{-1}}{dM} f(\sigma), \end{equation}\] <p>where \(\rho_o\) is the mean mass density of the universe. The form of \(f(\sigma; \vartheta)\) can be related analytically to cosmological parameters or approximated using simulations.</p> <p>If we rearrange the above equation for \(f(\sigma)\), we obtain</p> \[\begin{equation} f(\sigma) = \frac{M}{\rho_o} \frac{dn(M)}{d \ln (\sigma^{-1}(M))}, \end{equation}\] <p>Integrating the halo number density from a fixed mass \(M_{\rm cut}\) yields the number of halos with a mass above this threshold:</p> \[\begin{equation} N(M_i &gt; M_{\rm cut}) = \int_{M_{\rm cut}}^\infty \frac{dn}{dM} dM, \end{equation}\] <p>which in our case is the node cardinality of a halo graph, \(N^v\). By contrast, integrating the halo mass function from \(M_{\rm cut}\) yields the <em>fraction of total mass</em> residing in collapsed halos of mass above \(M_{\rm cut}\):</p> \[\begin{equation} F(M_i &gt; M_{\rm cut}) = \int_{M_{\rm cut}}^\infty f(\sigma) dM, \end{equation}\] <p>which incorporates <em>both</em> halo number \(N^v\) and mass information above \(M_{\rm cut}\).</p> <p>When graphs <em>aren’t</em> decorated with masses, the Fisher ellipse (green) rotates towards the <em>number density</em> contours (dashed lines) \(N(M_i &gt; M_{\rm cut})\), since this is the information the network receives: the number of halos above the mass cut.</p> <p>When we do specify masses, we see the Fisher (black) aligned with the integrated <em>halo mass</em> fraction lines (black lines) – our network has learned this concept automatically !</p> <h1 id="part-iii-a-more-realistic-case-adding-survey-noise">Part III: A more realistic case: adding survey noise</h1> <p>Now that we know the raw information content of the graph structure, we can see if gIMNNs would be useful for catalogues assembled with <em>noisy</em> halo or galaxy masses. Here we introduce a white noise model to the halo masses <em>before</em> making a catalogue cut at \(M_{\rm cut}\): \(\begin{equation} \hat{m}_i = m_i + \mathcal{N}(0,\sigma^2_{\rm noise}), \end{equation}\) where \(\sigma_{\rm noise}=A_{\rm noise}M_{\rm cut}\) with amplitude \(A_{\rm noise}\). Observed halos that fall below \(M_{\rm cut}\) are then trimmed from the graph to mimic real catalogue cuts in the presence of noisy mass estimates. We can think of this as a likelihood for a halo finder operating on noisy galaxy mass or luminosity measurements.</p> <figure class="align-center"> <p align="center"> <img src="/assets/img/cosmographs/masscut.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 10 </b> - Mass distribution after added noise, $\sigma_{\rm noise}=0.2 M_{\rm cut}$ (black) and simulated halo finder cuts (teal) for a single fiducial simulation for masses larger than $1.1 \times 10^{15}\ M_\odot$. The orange dashed lines indicates the minimum mass considered by the ``survey'' cutoff, $M_{\rm cut}=1.5\times 10^{15}\ M_\odot$. </div> </figure> <p>We can incorporate this forward model into the gIMNN training scheme such that the network becomes hardened to both the noisy halos and changing catalogue size.</p> <h2 id="training-curves">Training Curves</h2> <figure class="align-center"> <p align="center"> <img src="/assets/img/cosmographs/noisetraining.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 11 </b> - Validation curves for noisy masses. Smaller noise variance (darker curves) results in smaller per-epoch variance in $\det F$ and slightly more information extraction. Information leakage occurs with higher noise variance since smaller scales are poorly resolved and trimmed from the catalogue. </div> </figure> <p>In the above plot we see the effect of increasing the noise amplitude parameter \(A_{\rm noise}\) on IMNN training. Intuitively we’d expect the Fisher information estimate to fluctuate more as the lowest-mass halos in the survey become dominated by noise. More noise also means that the catalogue data becomes <em>less informative about the cosmology</em>, so the Fisher information drops slightly for the higher-noise cases. We term this <em>information leakage</em>, resulting in higher uncertainty contours in the Fisher plot:</p> <figure class="align-center"> <p align="center"> <img src="/assets/img/cosmographs/F_vary_mass_intfsigma.png" alt="drawing" width="65%"> </p> <div class="caption"> <b> Figure 12 </b> - Fisher constraints for different noise models, plotted over lines of the Press-Schechter halo mass function. </div> </figure> <p>We also plot the HMF lines for comparison and see that as the mass information becomes muddied by noise, the Fisher also <em>tilts away</em> from the HMF line alignment that we observe in the no-noise case (orange).</p> <h1 id="simulation-based-inference-how-to-use-gimnns-in-practice">Simulation-based Inference: How to use gIMNNs in Practice</h1> <p>This is largely an exploratory study to elucidate the information in cosmological catalogues by expressing the data as graphs. Along the way, however, we developed a technology that allows us to compress catalogues into neural summaries, \(\textbf{x}\). We can then compare simulated catalogues at different values of \(\theta\) to an actual dataset and accept-or-reject the simulations to build a posterior distribution. This scheme is called <em>Approximate Bayesian Computation</em> (ABC), and can be expensive for uninformative summary statistics. An even smarter approach is to use another set of neural networks to parameterize a posterior density. This technique, called Density Estimation Likelihood-Free Inference (DELFI), is what we used for our neural summaries in <a href="https://arxiv.org/abs/2107.07405" rel="external nofollow noopener" target="_blank">this paper</a>.</p> <h1 id="related-work">Related Work</h1> <p><strong>Neural Field-Level Information Extraction.</strong> This project is similar in style to <a href="https://arxiv.org/abs/2107.07405" rel="external nofollow noopener" target="_blank">field-level Information Maximising Neural Networks</a>. Both works aim to extract cosmological information from LSS. However, in our field-level study we assumed that we had access to the full density field image of a log-normal LSS simulation. We computed the analytic Fisher information for this field and showed that IMNNs with a CNN architecture can saturate the field-level information content–equivalent to writing a likelihood for every single pixel in the image ! We can think of the graph representation as a way to extract cosmological information when we don’t have a complete image of the underlying density field. Alternatively, we can think of images as 2D graphs bound to a lattice !</p> <h1 id="closing-thoughts">Closing Thoughts</h1> <p>In this study we investigated how much cosmological information is locked away in dark matter halo catalogues. To do this, we exploited the flexibility and symmetric properties of graphs to efficiently compress massive simulations down to a couple of numbers using graph neural networks.</p> <p>The language of graphs is an elegant way to describe the unintuitive nature of large-scale structure. Equipped with the technology of graph neural networks and a rigorous stastical metric (the Fisher information), we were able to cast cosmology as an optimization problem and find a way to squeeze more information out of catalogues than traditional statistics. We worked with really small catalogues, but demonstrated that even these structures are very sensitive to cosmology.</p> <p>We introduced new vocabulary with which to describe the cosmic web, and incorporated graph learning in the context of cosmological statistics. The extensions to this work are numerous, both within and outside of cosmology.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography><div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"alshedivat/al-folio","data-repo-id":"MDEwOlJlcG9zaXRvcnk2MDAyNDM2NQ==","data-category":"Comments","data-category-id":"DIC_kwDOA5PmLc4CTBt6","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,a])=>giscusScript.setAttribute(t,a)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 T. Lucas Makinen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>